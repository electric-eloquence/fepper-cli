#!/usr/bin/env node
'use strict';

const cp = require('child_process');
const fs = require('fs');
const path = require('path');

const enc = 'utf8';

// Recurse up the directory tree to find the parent directory of a given file.
function findup(filename, workDir) {
  const workDirFiles = fs.readdirSync(workDir);

  if (workDirFiles.indexOf(filename) > -1) {
    return workDir;
  }

  // Need to work with the operating system's path separators, so use Node path methods.
  const workDirUp = path.normalize(path.join(workDir, '..'));
  const workDirUpFiles = fs.readdirSync(workDirUp);
  let dirMatch = '';

  // Return the found directory if filename has been found.
  if (workDirUpFiles.indexOf(filename) > -1) {
    return workDirUp;
  }
  // Return empty string if reached end-of-the-line.
  else if (
    workDirUp === '/' ||
    /^[A-Z]:\\$/.test(workDirUp) ||
    workDirUp.slice(0, 2) === '\\\\'
  ) {
    return '';
  }
  // Otherwise, keep trying.
  else {
    dirMatch = findup(filename, workDirUp);
  }

  return dirMatch;
}

const cwd = process.cwd();
const isWindows = (process.env.ComSpec && process.env.ComSpec.toLowerCase() === 'c:\\windows\\system32\\cmd.exe');

// Invoke findup to retrieve the parent directory of fepper.command.
let rootDir = findup('fepper.command', cwd);

// None of these fepper scripts should be deleted, but just in case any are, offer a few more tries.
if (!rootDir) {
  rootDir = findup('fepper.ps1', cwd);
}

if (!rootDir) {
  rootDir = findup('fepper.vbs', cwd);
}

// Finally, if rootDir not found, console error and exit.
if (!rootDir) {
  // eslint-disable-next-line no-console
  console.error('It appears you are trying to run fp outside a working Fepper directory! Exiting!');

  return;
}

process.chdir(rootDir);

// Set some defaults.
let appDir = 'node_modules/fepper';
let killZombies = false;

// Read conf file.
const confFile = path.resolve(rootDir, 'conf.yml');
const confData = fs.readFileSync(confFile, enc).split('\n');

for (let confDatum of confData) {
  const confKeyVal = confDatum.split(':');

  if (!confKeyVal[1]) {
    continue;
  }

  // Trim whitespace from keys.
  const confKey = confKeyVal[0].trim();

  // Trim trailing inline comments from values.
  let confVal = confKeyVal[1];
  confVal = confVal.replace(/#.*/, '');
  // Trim whitespace from values.
  confVal = confVal.trim();

  switch (confKey) {
    case 'app_dir':
      appDir = confVal;

      break;

    case 'kill_zombies':
      killZombies = (confVal === 'true');

      break;
  }
}

if (isWindows) {
  // Use backslashes in Windows paths.
  appDir = appDir.replace(/\//g, '\\');
  // Killing zombies is only for BASH-like shells, not Windows.
  killZombies = false;
}

// Only kill zombies on default and restart tasks.
// Since no arg after element 1 means the default task, we only need to check when process.argv.length > 2.
if (process.argv.length > 2) {
  let i;

  for (i = 0; i < process.argv.length; i++) {
    if (process.argv[i] === 'default' || process.argv[i] === 'restart') {
      break;
    }
  }

  // If the previous loop was not broken by discovery of a "default" or "restart" arg, do not kill zombies.
  if (i === process.argv.length) {
    killZombies = false;
  }
}

if (killZombies) {
  const spawnObj = cp.spawnSync('pgrep', ['-x', 'gulp']);
  const gulpPids = spawnObj.stdout.toString(enc).trim().split('\n');

  for (let gulpPid of gulpPids) {
    cp.spawnSync('kill', [gulpPid], {stdio: 'inherit'});
    // eslint-disable-next-line no-console
    console.log(`Killing gulp process ${gulpPid}.`);
  }
}

const argv = ['--gulpfile', path.resolve(rootDir, appDir, 'tasker.js')];

// Set up array of args for submission to Gulp.
if (process.argv.length < 3) {
  argv[2] = 'default';
}
else {
  for (let i = 2; i < process.argv.length; i++) {
    argv[i] = process.argv[i];
  }
}

const indexOfD = argv.indexOf('-d');
const indexOfDebug = argv.indexOf('--debug');

if (indexOfD > -1 || indexOfDebug > -1) {
  process.env.DEBUG = true;

  if (indexOfD > -1) {
    argv.splice(indexOfD, 1);
  }
  else if (indexOfDebug > -1) {
    argv.splice(indexOfDebug, 1);
  }
}

// The "HEADED" process.env var is deprecated. It will be removed.
if (!process.env.HEADED) {
  process.env.HEADED = true;
}

if (!process.env.ROOT_DIR) {
  process.env.ROOT_DIR = rootDir;
}

process.env.NODE_PATH = path.resolve(process.env.ROOT_DIR, 'node_modules');

const binPath = path.resolve('node_modules', '.bin');
let binGulp = path.resolve(binPath, 'gulp');

// Spawn gulp.cmd if Windows and not BASH.
if (isWindows) {
  binGulp = path.resolve(binPath, 'gulp.cmd');
}

// Spawn gulp task with arguments.
cp.spawn(binGulp, argv, {stdio: 'inherit', env: process.env});
